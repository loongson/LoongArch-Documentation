= LoongArch ELF ABI specification
Loongson Technology Corporation Limited
v1.00
:docinfodir: ../themes
:docinfo: shared
:doctype: book
:toc: left

== Register Convention

.Integer Register Convention
[%header,cols="2m,2m,^5,^3"]
|===
|Name
|Alias
|Meaning
|Preserved across calls

|$r0
|$zero
|Constant zero
|--

|$r1
|$ra
|Return address
|No

|$r2
|$tp
|Thread pointer
|-- (Unallocatable)

|$r3
|$sp
|Stack pointer
|Yes

|$r4-$r11
|$a0-$a7
|Argument registers
|No

|$r4-$r5
|$v0-$v1
|Return value
|No

|$r12-$r20
|$t0-$t8
|Temporary registers
|No

|$r21
|--
|Reserved
|-- (Unallocatable)

|$r22
|$fp/$s9
|Frame pointer/Static register
|Yes

|$r23-$r31
|$s0-$s8
|Static registers
|Yes
|===

.Floating-point Register Convention
[%header,cols="2m,2m,^5,^3"]
|===
|Name
|Alias
|Meaning
|Preserved across calls

|$f0-$f7
|$fa0-$fa7
|Argument registers
|No

|$f0-$f1
|$fv0-$fv7
|Return value
|No

|$f8-$f23
|$ft0-$ft15
|Temporary registers
|No

|$f24-$f31
|$fs0-$fs7
|Static registers
|Yes
|===

Temporary registers are also known as caller-saved registers.
Static registers are also known as callee-saved registers.

== Type Size and Alignment

.LP64 ABI
[%header,cols="3m,^1,^1"]
|===
|Scalar type
|Size(Bytes)
|Alignment(Bytes)

|bool/_Bool
|1
|1

|unsigned/signed char
|1
|1

|unsigned/signed short
|2
|2

|unsigned/signed int
|4
|4

|unsigned/signed long
|8
|8

|unsigned/signed long long
|8
|8

|pointer
|8
|8

|float
|4
|4

|double
|8
|8

|long double
|16
|16
|===

`char` is signed.

== ELF Object Files

=== EI_CLASS: File class

[%header,cols="2m,^1,^3"]
|===
|EI_CLASS
|Value
|Description

|ELFCLASS32
|1
|32-bit objects

|ELFCLASS64
|2
|64-bit objects
|===

=== e_machine: Identifies the machine

`LoongArch (258)`

=== e_flags: Identifies the ABIs of this ELF file

[%header,cols="1,1,1"]
|========================================================
| Bit 0 - 1 | Bit 2 - 5 | Bit 6 - 31

| integer ABI | floating-point/extended ABI | (reserved)
|========================================================

The ABI type of an ELF object is described by `e_flags[5:0]` in its header,
where `e_flags[1:0]` encodes its integer ABI type while `e_flags[5:2]` encodes
the floating-point/extended ABI type.

.Integer ABI types
[%header,cols="2m,^1,^3"]
|===
|Name
|`e_flags[1:0]`
|Description

|lp64
|`0b11`
|64-bit GPRs and the stack are used for parameter passing.

|ilp32
|`0b01`
|32-bit GPRs and the stack are used for parameter passing.

|(reserved)
|`0b10` `0b00`
|--
|===

.Floating-point / extended ABI types
[%header,cols="2m,^1,^3"]
|===
|Name
|`e_flags[5:2]`
|Description

|double
|`0b0000`
|64-bit FPRs are used for parameter passing.

|soft
|`0b0011`
|No FPR is used for parameter passing.

|single
|`0b0010`
|32-bit FPRs are used for parameter passing.

|(reserved)
|`0b0001` `0b0100 - 0b1111`
|--
|===

=== ABI Version

[%header,cols="2m,^1,^5"]
|===
|ABI Version:
|Value
|Description

|v0
|0
|Stack operands base relocation type.

|v1
|1
|Another relocation type IF needed.

|--
|2 --
|Reserved.
|===

== Relocations

.ELF Relocation types
[%header,cols="^1,^2m,^5,5"]
|===
|Enum
|ELF reloc type
|Usage
|Detail

|0
|R_LARCH_NONE
|
|

|1
|R_LARCH_32
|Runtime address resolving
|`+*(int32_t *) PC = RtAddr + A+`

|2
|R_LARCH_64
|Runtime address resolving
|`+*(int64_t *) PC = RtAddr + A+`

|3
|R_LARCH_RELATIVE
|Runtime fixup for load-address
|`+*(void **) PC = B + A+`

|4
|R_LARCH_COPY
|Runtime memory copy in executable
|`+memcpy (PC, RtAddr, sizeof (sym))+`

|5
|R_LARCH_JUMP_SLOT
|Runtime PLT supporting
|_implementation-defined_

|6
|R_LARCH_TLS_DTPMOD32
|Runtime relocation for TLS-GD
|`+*(int32_t *) PC = ID of module defining sym+`

|7
|R_LARCH_TLS_DTPMOD64
|Runtime relocation for TLS-GD
|`+*(int64_t *) PC = ID of module defining sym+`

|8
|R_LARCH_TLS_DTPREL32
|Runtime relocation for TLS-GD
|`+*(int32_t *) PC = DTV-relative offset for sym+`

|9
|R_LARCH_TLS_DTPREL64
|Runtime relocation for TLS-GD
|`+*(int64_t *) PC = DTV-relative offset for sym+`

|10
|R_LARCH_TLS_TPREL32
|Runtime relocation for TLE-IE
|`+*(int32_t *) PC = T+`

|11
|R_LARCH_TLS_TPREL64
|Runtime relocation for TLE-IE
|`+*(int64_t *) PC = T+`

|12
|R_LARCH_IRELATIVE
|Runtime local indirect function resolving
|`+*(void **) PC = (((void *)(*)()) (B + A)) ()+`

4+|... Reserved for dynamic linker.

|20
|R_LARCH_MARK_LA
|Mark la.abs
|Load absolute address for static link.

|21
|R_LARCH_MARK_PCREL
|Mark external label branch
|Access PC relative address for static link.

|22
|R_LARCH_SOP_PUSH_PCREL
|Push PC-relative offset
|`+push (S - PC + A)+`

|23
|R_LARCH_SOP_PUSH_ABSOLUTE
|Push constant or absolute address
|`+push (S + A)+`

|24
|R_LARCH_SOP_PUSH_DUP
|Duplicate stack top
|`+opr1 = pop (), push (opr1), push (opr1)+`

|25
|R_LARCH_SOP_PUSH_GPREL
|Push for access GOT entry
|`+push (G)+`

|26
|R_LARCH_SOP_PUSH_TLS_TPREL
|Push for TLS-LE
|`+push (T)+`

|27
|R_LARCH_SOP_PUSH_TLS_GOT
|Push for TLS-IE
|`+push (IE)+`

|28
|R_LARCH_SOP_PUSH_TLS_GD
|Push for TLS-GD
|`+push (GD)+`

|29
|R_LARCH_SOP_PUSH_PLT_PCREL
|Push for external function calling
|`+push (PLT - PC)+`

|30
|R_LARCH_SOP_ASSERT
|Assert stack top
|`+assert (pop ())+`

|31
|R_LARCH_SOP_NOT
|Stack top operation
|`+push (!pop ())+`

|32
|R_LARCH_SOP_SUB
|Stack top operation
|`+opr2 = pop (), opr1 = pop (), push (opr1 - opr2)+`

|33
|R_LARCH_SOP_SL
|Stack top operation
|`+opr2 = pop (), opr1 = pop (), push (opr1 << opr2)+`

|34
|R_LARCH_SOP_SR
|Stack top operation
|`+opr2 = pop (), opr1 = pop (), push (opr1 >> opr2)+`

|35
|R_LARCH_SOP_ADD
|Stack top operation
|`+opr2 = pop (), opr1 = pop (), push (opr1 + opr2)+`

|36
|R_LARCH_SOP_AND
|Stack top operation
|`+opr2 = pop (), opr1 = pop (), push (opr1 & opr2)+`

|37
|R_LARCH_SOP_IF_ELSE
|Stack top operation
|`+opr3 = pop (), opr2 = pop (), opr1 = pop (), push (opr1 ? opr2 : opr3)+`

|38
|R_LARCH_SOP_POP_32_S_10_5
|Instruction imm-field relocation
|`+opr1 = pop (), (*(uint32_t *) PC) [14 ... 10] = opr1 [4 ... 0]+`

with check 5-bit signed overflow

|39
|R_LARCH_SOP_POP_32_U_10_12
|Instruction imm-field relocation
|`+opr1 = pop (), (*(uint32_t *) PC) [21 ... 10] = opr1 [11 ... 0]+`

with check 12-bit unsigned overflow

|40
|R_LARCH_SOP_POP_32_S_10_12
|Instruction imm-field relocation
|`+opr1 = pop (), (*(uint32_t *) PC) [21 ... 10] = opr1 [11 ... 0]+`

with check 12-bit signed overflow

|41
|R_LARCH_SOP_POP_32_S_10_16
|Instruction imm-field relocation
|`+opr1 = pop (), (*(uint32_t *) PC) [25 ... 10] = opr1 [15 ... 0]+`

with check 16-bit signed overflow

|42
|R_LARCH_SOP_POP_32_S_10_16_S2
|Instruction imm-field relocation
|`+opr1 = pop (), (*(uint32_t *) PC) [25 ... 10] = opr1 [17 ... 2]+`

with check 18-bit signed overflow and 4-bit aligned

|43
|R_LARCH_SOP_POP_32_S_5_20
|Instruction imm-field relocation
|`+opr1 = pop (), (*(uint32_t *) PC) [24 ... 5] = opr1 [19 ... 0]+`

with check 20-bit signed overflow

|44
|R_LARCH_SOP_POP_32_S_0_5_10_16_S2
|Instruction imm-field relocation
|`+opr1 = pop (), (*(uint32_t *) PC) [4 ... 0] = opr1 [22 ... 18],+`

`+(*(uint32_t *) PC) [25 ... 10] = opr1 [17 ... 2]+`

with check 23-bit signed overflow and 4-bit aligned

|45
|R_LARCH_SOP_POP_32_S_0_10_10_16_S2
|Instruction imm-field relocation
|`+opr1 = pop (), (*(uint32_t *) PC) [9 ... 0] = opr1 [27 ... 18],+`

`+(*(uint32_t *) PC) [25 ... 10] = opr1 [17 ... 2]+`

with check 28-bit signed overflow and 4-bit aligned

|46
|R_LARCH_SOP_POP_32_U
|Instruction fixup
|`+(*(uint32_t *) PC) = pop ()+`

with check 32-bit unsigned overflow

|47
|R_LARCH_ADD8
|8-bit in-place addition
|`+*(int8_t *) PC += S + A+`

|48
|R_LARCH_ADD16
|16-bit in-place addition
|`+*(int16_t *) PC += S + A+`

|49
|R_LARCH_ADD24
|24-bit in-place addition
|`+*(int24_t *) PC += S + A+`

|50
|R_LARCH_ADD32
|32-bit in-place addition
|`+*(int32_t *) PC += S + A+`

|51
|R_LARCH_ADD64
|64-bit in-place addition
|`+*(int64_t *) PC += S + A+`

|52
|R_LARCH_SUB8
|8-bit in-place subtraction
|`+*(int8_t *) PC -= S + A+`

|53
|R_LARCH_SUB16
|16-bit in-place subtraction
|`+*(int16_t *) PC -= S + A+`

|54
|R_LARCH_SUB24
|24-bit in-place subtraction
|`+*(int24_t *) PC -= S + A+`

|55
|R_LARCH_SUB32
|32-bit in-place subtraction
|`+*(int32_t *) PC -= S + A+`

|56
|R_LARCH_SUB64
|64-bit in-place subtraction
|`+*(int64_t *) PC -= S + A+`

|57
|R_LARCH_GNU_VTINHERIT
|GNU C++ vtable hierarchy
|

|58
|R_LARCH_GNU_VTENTRY
|GNU C++ vtable member usage
|
|===

== Compiler Options and Library Path Conventions

=== Compiler Options

The command-line options listed below should denote a change
in the following compiler settings:

1. ABI type of compiled subroutines

2. Available ISA extensions

3. Processor-model-specific tuning parameters

.Compiler Options:
[%header,cols="^1m,^2,^7"]
|===
|Option
|Values
|Description

|-march=
|`native` `loongarch64` `la464`
|Target CPU model (implies default ABI type, ISA extension and tuning parameters)

|-mtune=
|`native` `loongarch64` `la464`
|Target CPU model (tuning parameters)

|-mabi=
|`lp64` `ilp32`
|Integer ABI type

|-mfloat-abi=
|`double` `single` `soft`
|Floating-point / extended ABI type

|-mfpu=
|`double` `single` `none`
|Floating-point ISA / SIMD extensions

|-msoft-float
|`--`
|alias for `-mfloat-abi=soft -mfpu=none`

|-msingle-float
|`--`
|alias for `-mfloat-abi=single -mfpu=single`

|-mdouble-float
|`--`
|alias for `-mfloat-abi=double -mfpu=double`
|===

=== GNU/Linux Library Path Conventions

.Library Path Conventions of ABI types
[%header,cols="^1m,^3m,^3m,^3m"]
|===
|ABI Type
|Standard Library Search Path
|Multiarch Library Path
|Program Interpreter Path

|lp64/double
|/lib64
|/lib/loongarch64-linux-gnu
|/lib64/ld-linux-loongarch-lp64-df.so

|lp64/single
|/lib64/single
|/lib/loongarch64-linux-gnu/single
|/lib64/ld-linux-loongarch-lp64-sf.so

|lp64/soft
|/lib64/soft
|/lib/loongarch64-linux-gnu/soft
|/lib64/ld-linux-loongarch-lp64-nf.so

|ilp32/double
|/lib32
|/lib/loongarch32-linux-gnu
|/lib32/ld-linux-loongarch-ilp32-df.so

|ilp32/single
|/lib32/single
|/lib/loongarch32-linux-gnu/single
|/lib32/ld-linux-loongarch-ilp32-sf.so

|ilp32/soft
|/lib32/soft
|/lib/loongarch32-linux-gnu/soft
|/lib32/ld-linux-loongarch-ilp32-nf.so
|===

Other path conventions:

. On a GNU/Linux distribution, either `/lib` or `/usr/lib` should be symlinked
  to the standard library path of the primary integer ABI type of the
  binary executables supplied by the distribution.

. For multiarch-style filesystem layouts, two canonical target triplets are defined:
  `loongarch64-linux-gnu` and `loongarch32-linux-gnu`.
  On a LoongArch distribution with multiarch layout, `/lib/loongarch64-linux-gnu` /
  `/lib/loongarch32-linux-gnu` should be symlinked to `/lib64` / `/lib32`.
