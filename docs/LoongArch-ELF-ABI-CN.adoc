= 龙芯架构 ELF psABI 规范
龙芯中科技术股份有限公司
v1.00
:docinfodir: ../themes
:docinfo: shared
:doctype: book
:toc: left
:toc-title: 目录
:scripts: cjk

== 寄存器使用约定

.通用寄存器使用约定
[%header,cols="2m,2m,^5,^3"]
|===
|名称
|别名
|用途
|在调用中是否保留

|$r0
|$zero
|常数 0
|--

|$r1
|$ra
|返回地址
|否

|$r2
|$tp
|线程指针
|-- （不可分配）

|$r3
|$sp
|栈指针
|是

|$r4-$r11
|$a0-$a7
|传参寄存器
|否

|$r4-$r5
|$v0-$v1
|返回值
|否

|$r12-$r20
|$t0-$t8
|临时寄存器
|否

|$r21
|--
|保留
|-- （不可分配）

|$r22
|$fp/$s9
|栈帧指针 / 静态寄存器
|是

|$r23-$r31
|$s0-$s8
|静态寄存器
|是
|===

.浮点寄存器使用约定
[%header,cols="2m,2m,^5,^3"]
|===
|名称
|别名
|用途
|在调用中是否保留

|$f0-$f7
|$fa0-$fa7
|传参寄存器
|否

|$f0-$f1
|$fv0-$fv7
|返回值
|否

|$f8-$f23
|$ft0-$ft15
|临时寄存器
|否

|$f24-$f31
|$fs0-$fs7
|静态寄存器
|是
|===

临时寄存器也被称为调用者保存寄存器。
静态寄存器也被称为被调用者保存寄存器。

== C 语言数据类型规格

.LP64 ABI
[%header,cols="3m,^1,^1"]
|===
|标量类型
|大小（字节）
|对齐（字节）

|bool/_Bool
|1
|1

|unsigned/signed char
|1
|1

|unsigned/signed short
|2
|2

|unsigned/signed int
|4
|4

|unsigned/signed long
|8
|8

|unsigned/signed long long
|8
|8

|指针类型
|8
|8

|float
|4
|4

|double
|8
|8

|long double
|16
|16
|===

`char` 是有符号类型。

== ELF 目标文件

=== EI_CLASS: ELF 文件格式

[%header,cols="2m,^1,^3"]
|===
|EI_CLASS
|枚举值
|含义

|ELFCLASS32
|1
|32 位 ELF 格式

|ELFCLASS64
|2
|64 位 ELF 格式
|===

=== e_machine: 体系结构 ID

`LoongArch (258)`

=== e_flags: ABI 类型标记

[%header,cols="1,1,1"]
|=========================================
|`[1:0]` 位 | `[5:2]` 位  | `[31:6]` 位

| 整型 ABI  | 浮点 / 扩展 ABI | （保留）
|=========================================

`e_flags[5:0]` 标记了 ELF 目标文件使用的 ABI 类型。
其中， `e_flags[1:0]` 标记整型 ABI， `e_flags[5:2]` 标记浮点 / 扩展 ABI。

.整型 ABI 标记
[%header,cols="2m,^1,^3"]
|===
|整型 ABI 名称
|枚举值
|含义

|lp64
|`0b11`
|使用 64 位通用寄存器和栈传参

|ilp32
|`0b01`
|使用 32 位通用寄存器和栈传参

|（保留值）
|`0b10` `0b00`
|--
|===

.浮点 / 扩展 ABI 标记
[%header,cols="2m,^1,^3"]
|===
|浮点 / 扩展 ABI 名称
|枚举值
|含义

|double
|`0b0000`
|使用 64 位浮点寄存器传参

|soft
|`0b0011`
|不使用浮点寄存器传参

|single
|`0b0010`
|使用 32 位浮点寄存器传参

|（保留值）
|`0b0001` `0b0100 - 0b1111`
|--
|===

=== ABI 版本

[%header,cols="2m,^1,^5"]
|===
|ABI 版本
|枚举值
|描述

|v0
|0
|支持具有栈操作语义的重定位类型（旧版兼容）

|v1
|1
|新版重定位类型

|--
|2 --
|（保留值）
|===

== 重定位类型

.ELF 重定位类型
[%header,cols="^1,^2m,^5,5"]
|===
|枚举值
|名称
|描述
|语义

|0
|R_LARCH_NONE
|
|

|1
|R_LARCH_32
|动态符号地址解析
|`+*(int32_t *) PC = RtAddr + A+`

|2
|R_LARCH_64
|动态符号地址解析
|`+*(int64_t *) PC = RtAddr + A+`

|3
|R_LARCH_RELATIVE
|模块动态加载地址修正
|`+*(void **) PC = B + A+`

|4
|R_LARCH_COPY
|可执行映像数据动态填充
|`+memcpy (PC, RtAddr, sizeof (sym))+`

|5
|R_LARCH_JUMP_SLOT
|PLT 跳转支持
|_由具体实现定义_

|6
|R_LARCH_TLS_DTPMOD32
|TLS-GD 动态重定位支持
|`+*(int32_t *) PC = ID of module defining sym+`

|7
|R_LARCH_TLS_DTPMOD64
|TLS-GD 动态重定位支持
|`+*(int64_t *) PC = ID of module defining sym+`

|8
|R_LARCH_TLS_DTPREL32
|TLS-GD 动态重定位支持
|`+*(int32_t *) PC = DTV-relative offset for sym+`

|9
|R_LARCH_TLS_DTPREL64
|TLS-GD 动态重定位支持
|`+*(int64_t *) PC = DTV-relative offset for sym+`

|10
|R_LARCH_TLS_TPREL32
|TLS-IE 动态重定位支持
|`+*(int32_t *) PC = T+`

|11
|R_LARCH_TLS_TPREL64
|TLS-IE 动态重定位支持
|`+*(int64_t *) PC = T+`

|12
|R_LARCH_IRELATIVE
|本地间接跳转解析
|`+*(void **) PC = (((void *)(*)()) (B + A)) ()+`

4+|... 动态链接器保留项

|20
|R_LARCH_MARK_LA
|标记 la.abs 宏指令
|静态填充符号绝对地址

|21
|R_LARCH_MARK_PCREL
|标记外部标签跳转
|静态填充符号地址偏移量

|22
|R_LARCH_SOP_PUSH_PCREL
|将符号相对地址压栈
|`+push (S - PC + A)+`

|23
|R_LARCH_SOP_PUSH_ABSOLUTE
|将常数或绝对地址压栈
|`+push (S + A)+`

|24
|R_LARCH_SOP_PUSH_DUP
|复制栈顶元素
|`+opr1 = pop (), push (opr1), push (opr1)+`

|25
|R_LARCH_SOP_PUSH_GPREL
|将符号的 GOT 表项偏移量压栈
|`+push (G)+`

|26
|R_LARCH_SOP_PUSH_TLS_TPREL
|将 TLS-LE 偏移量压栈
|`+push (T)+`

|27
|R_LARCH_SOP_PUSH_TLS_GOT
|将 TLS-IE 偏移量压栈
|`+push (IE)+`

|28
|R_LARCH_SOP_PUSH_TLS_GD
|将 TLS-GD 偏移量压栈
|`+push (GD)+`

|29
|R_LARCH_SOP_PUSH_PLT_PCREL
|将符号 PLT stub 的地址偏移量压栈
|`+push (PLT - PC)+`

|30
|R_LARCH_SOP_ASSERT
|断言栈顶元素为真
|`+assert (pop ())+`

|31
|R_LARCH_SOP_NOT
|栈顶运算
|`+push (!pop ())+`

|32
|R_LARCH_SOP_SUB
|栈顶运算
|`+opr2 = pop (), opr1 = pop (), push (opr1 - opr2)+`

|33
|R_LARCH_SOP_SL
|栈顶运算
|`+opr2 = pop (), opr1 = pop (), push (opr1 << opr2)+`

|34
|R_LARCH_SOP_SR
|栈顶运算
|`+opr2 = pop (), opr1 = pop (), push (opr1 >> opr2)+`

|35
|R_LARCH_SOP_ADD
|栈顶运算
|`+opr2 = pop (), opr1 = pop (), push (opr1 + opr2)+`

|36
|R_LARCH_SOP_AND
|栈顶运算
|`+opr2 = pop (), opr1 = pop (), push (opr1 & opr2)+`

|37
|R_LARCH_SOP_IF_ELSE
|栈顶运算
|`+opr3 = pop (), opr2 = pop (), opr1 = pop (), push (opr1 ? opr2 : opr3)+`

|38
|R_LARCH_SOP_POP_32_S_10_5
|指令立即数重定位
|`+opr1 = pop (), (*(uint32_t *) PC) [14 ... 10] = opr1 [4 ... 0]+`

带 5 位有符号数溢出检测功能

|39
|R_LARCH_SOP_POP_32_U_10_12
|指令立即数重定位
|`+opr1 = pop (), (*(uint32_t *) PC) [21 ... 10] = opr1 [11 ... 0]+`

带 12 位无符号数溢出检测功能

|40
|R_LARCH_SOP_POP_32_S_10_12
|指令立即数重定位
|`+opr1 = pop (), (*(uint32_t *) PC) [21 ... 10] = opr1 [11 ... 0]+`

带 12 位有符号数溢出检测功能

|41
|R_LARCH_SOP_POP_32_S_10_16
|指令立即数重定位
|`+opr1 = pop (), (*(uint32_t *) PC) [25 ... 10] = opr1 [15 ... 0]+`

带 16 位有符号数溢出检测功能

|42
|R_LARCH_SOP_POP_32_S_10_16_S2
|指令立即数重定位
|`+opr1 = pop (), (*(uint32_t *) PC) [25 ... 10] = opr1 [17 ... 2]+`

带 18 位有符号数溢出和4字节对齐检测功能

|43
|R_LARCH_SOP_POP_32_S_5_20
|指令立即数重定位
|`+opr1 = pop (), (*(uint32_t *) PC) [24 ... 5] = opr1 [19 ... 0]+`

带 20 位有符号数溢出检测功能

|44
|R_LARCH_SOP_POP_32_S_0_5_10_16_S2
|指令立即数重定位
|`+opr1 = pop (), (*(uint32_t *) PC) [4 ... 0] = opr1 [22 ... 18],+`

`+(*(uint32_t *) PC) [25 ... 10] = opr1 [17 ... 2]+`

带 23 位有符号数溢出和4字节对齐检测功能

|45
|R_LARCH_SOP_POP_32_S_0_10_10_16_S2
|指令立即数重定位
|`+opr1 = pop (), (*(uint32_t *) PC) [9 ... 0] = opr1 [27 ... 18],+`

`+(*(uint32_t *) PC) [25 ... 10] = opr1 [17 ... 2]+`

带 28 位有符号数溢出和4字节对齐检测功能

|46
|R_LARCH_SOP_POP_32_U
|指令修正
|`+(*(uint32_t *) PC) = pop ()+`

带 32 位无符号数溢出检测功能

|47
|R_LARCH_ADD8
|8 位原地加法
|`+*(int8_t *) PC += S + A+`

|48
|R_LARCH_ADD16
|16 位原地加法
|`+*(int16_t *) PC += S + A+`

|49
|R_LARCH_ADD24
|24 位原地加法
|`+*(int24_t *) PC += S + A+`

|50
|R_LARCH_ADD32
|32 位原地加法
|`+*(int32_t *) PC += S + A+`

|51
|R_LARCH_ADD64
|64 位原地加法
|`+*(int64_t *) PC += S + A+`

|52
|R_LARCH_SUB8
|8 位原地减法
|`+*(int8_t *) PC -= S + A+`

|53
|R_LARCH_SUB16
|16 位原地减法
|`+*(int16_t *) PC -= S + A+`

|54
|R_LARCH_SUB24
|24 位原地减法
|`+*(int24_t *) PC -= S + A+`

|55
|R_LARCH_SUB32
|32 位原地减法
|`+*(int32_t *) PC -= S + A+`

|56
|R_LARCH_SUB64
|64 位原地减法
|`+*(int64_t *) PC -= S + A+`

|57
|R_LARCH_GNU_VTINHERIT
|GNU C++ vtable 支持
|

|58
|R_LARCH_GNU_VTENTRY
|GNU C++ vtable 支持
|
|===

== 编译器选项和路径惯例

=== 编译器选项

以下编译器选项的最终效应包括：

1. 配置使用的 ABI 类型

2. 配置使用的 ISA 扩展

3. 配置处理器型号相关的调优参数

.编译器选项列表：
[%header,cols="^1m,^2,^7"]
|===
|选项
|可用值
|描述

|-march=
|`native` `loongarch64` `la464`
|选择目标 CPU (隐含默认 ABI 类型、ISA 扩展和调优参数)

|-mtune=
|`native` `loongarch64` `la464`
|选择目标 CPU 的性能调优参数

|-mabi=
|`lp64` `ilp32`
|选择整型 ABI 类型

|-mfloat-abi=
|`double` `single` `soft`
|选择浮点 / 扩展 ABI 类型

|-mfpu=
|`double` `single` `none`
|选择编译器可用的浮点 / 扩展指令集

|-msoft-float
|`--`
|`-mfloat-abi=soft -mfpu=none` 的简写

|-msingle-float
|`--`
|`-mfloat-abi=single -mfpu=single` 的简写

|-mdouble-float
|`--`
|`-mfloat-abi=double -mfpu=double` 的简写
|===

=== GNU/Linux 文件系统路径惯例

.各 ABI 类型对应的文件系统路径惯例：
[%header,cols="^1m,^3m,^3m,^3m"]
|===
|ABI 类型
|标准库路径
|multiarch库路径
|标准动态链接器路径

|lp64/double
|/lib64
|/lib/loongarch64-linux-gnu
|/lib64/ld-linux-loongarch-lp64-df.so

|lp64/single
|/lib64/single
|/lib/loongarch64-linux-gnu/single
|/lib64/ld-linux-loongarch-lp64-sf.so

|lp64/soft
|/lib64/soft
|/lib/loongarch64-linux-gnu/soft
|/lib64/ld-linux-loongarch-lp64-nf.so

|ilp32/double
|/lib32
|/lib/loongarch32-linux-gnu
|/lib32/ld-linux-loongarch-ilp32-df.so

|ilp32/single
|/lib32/single
|/lib/loongarch32-linux-gnu/single
|/lib32/ld-linux-loongarch-ilp32-sf.so

|ilp32/soft
|/lib32/soft
|/lib/loongarch32-linux-gnu/soft
|/lib32/ld-linux-loongarch-ilp32-nf.so
|===

其他路径惯例规则：

. 在 GNU/Linux 发行版上， `/lib` 或 `/usr/lib` 路径应当为软链接，
  指向该发行版二进制程序主要使用的整型 ABI 类型所对应的库搜索路径
  （ `lib32` 或 `lib64` ）。

. 在 GNU/Linux multiarch 路径惯例下，共定义两个规范的目标三元组名称：
  `loongarch64-linux-gnu` 和 `loongarch32-linux-gnu` 。
  在龙芯架构发行版上， `/lib/loongarch64-linux-gnu` / `/lib/loongarch32-linux-gnu`
  应创建为指向 `/lib64` / `/lib32` 目录的软链接。
